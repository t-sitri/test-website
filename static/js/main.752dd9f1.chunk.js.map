{"version":3,"sources":["logo.svg","App.js","serviceWorker.js","index.js"],"names":["module","exports","Tool","props","handleClick","bind","event","window","current","this","width","src","url","alt","altText","onClick","React","Component","dothing","canvas","coordinates","ctx","getContext","rect","getBoundingClientRect","x","y","imageData","getImageData","left","top","data","console","log","donothing","CanvasComponent","clientX","clientY","replace","onCanvasClick","refs","drawImage","handleHover","onCanvasHover","getInput","fileInput","createRef","preventDefault","image","Image","URL","createObjectURL","files","onload","naturalWidth","height","naturalHeight","type","accept","ref","onChange","onMouseDown","onMouseMove","paintBucketClick","currPixel","matrix","to_ret","temp","group","length","i","push","imageDataToMatrix","visited","recursivelyPaintBucket","currentCoordinates","tolerance","colourToReplace","colourToCompare","currentPixel","canDoIt","Math","abs","j","text","App","className","Boolean","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.752dd9f1.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/logo.5d5d9eef.svg\";","import React from 'react';\nimport logo from './logo.svg';\nimport './App.css';\n\n// Whatever tool you implement will extend this class\nclass Tool extends React.Component {\n  constructor(props) {\n    super(props);\n    this.handleClick = this.handleClick.bind(this);\n  }\n\n  handleClick(event) {\n    window.current = this; \n  }\n\n  render() {\n    return (\n    <img width=\"50px\" src={this.props.url} alt={this.props.altText} onClick={this.handleClick}/>\n    );\n  }\n}\n\n// Example Functions \nfunction dothing(canvas, coordinates) {\n  var ctx = canvas.getContext(\"2d\");\n  let rect = canvas.getBoundingClientRect();\n  var x = coordinates[0]; var y = coordinates[1];\n  let imageData = ctx.getImageData(x - rect.left, y - rect.top, 1,1).data;\n  console.log(imageData);\n  return canvas; \n}\n\nfunction donothing(canvas, coordinates) {\n  console.log(coordinates);\n  return canvas; \n}\n//\n//\n\n// How we interact with the canvas \nclass CanvasComponent extends React.Component {\n constructor(props) {\n  super(props);\n  this.getInput = this.getInput.bind(this);\n  this.fileInput = React.createRef(); \n }\n getInput(event) {\n   \n   event.preventDefault();\n   var image = new Image();\n   image.src = URL.createObjectURL(this.fileInput.current.files[0]);\n   image.onload = () => {this.drawImage(image)};\n  \n }\n\n drawImage(image) {\n  const canvas = this.refs.canvas;\n  const ctx = canvas.getContext(\"2d\");\n  canvas.width = image.naturalWidth;\n  canvas.height = image.naturalHeight; \n  \n  ctx.drawImage(image,0,0);\n }\n\n  handleClick = (event) => {\n    // should take: complete canvas, current mouse coordinates\n    // should return: modified canvas\n    var coordinates = [event.clientX, event.clientY];\n    \n    const replace = window.current.props.onCanvasClick(this.refs.canvas,coordinates);\n    this.refs.canvas.getContext(\"2d\").drawImage(replace, 0,0);\n  }\n\n  handleHover = (event) => {\n    // should take: complete canvas, current mouse coordinates\n    // should return: modified canvas\n    var coordinates = [event.clientX, event.clientY];\n    \n    const replace = window.current.props.onCanvasHover(this.refs.canvas,coordinates);\n    this.refs.canvas.getContext(\"2d\").drawImage(replace, 0,0);\n  }\n\n  render() {\n      return (\n        <span>\n          <input type=\"file\" accept=\"image/*\" ref={this.fileInput} onChange={this.getInput}/> <br/>\n          <canvas ref=\"canvas\" width={300} height={300} onMouseDown={this.handleClick} onMouseMove={this.handleHover}></canvas>\n        </span>\n      );\n  }\n}\n\n\n\nfunction paintBucketClick(canvas, coordinates) {\n  var ctx = canvas.getContext(\"2d\");\n  let rect = canvas.getBoundingClientRect();\n  var x = coordinates[0]; var y = coordinates[1];\n  let currPixel = ctx.getImageData(x - rect.left, y - rect.top, 1,1).data;\n  const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n  let matrix = imageDataToMatrix(imageData, canvas.width);\n\n  let visited = {};\n  \n  function recursivelyPaintBucket(currentCoordinates, tolerance, colourToReplace, colourToCompare) {\n    if(!(currentCoordinates in visited) && (currentCoordinates[0] >= 0 && currentCoordinates[1] >= 0 && currentCoordinates[0] <= canvas.width && currentCoordinates[1] <= canvas.height)) {\n      const currentPixel = matrix[currentCoordinates[1]][currentCoordinates[0]];\n      var canDoIt = true;\n      for(var i = 0; i < 3; i ++ ) {\n        if(Math.abs(currentPixel[i]-colourToCompare[i])/255 > tolerance) {\n          canDoIt = false;\n          break;\n        }\n      }\n      if(canDoIt) {\n        // change the value of the current pixel\n        for(var j = 0; j < 3; j ++ ) {\n          currentPixel[j] = colourToReplace[j];\n        }\n        currentPixel[4] = 255;\n\n        // add the nearby pixels\n        const coordinatesToCheck = [[coordinates[0] - 1, coordinates[1]], [coordinates[0], coordinates[1] - 1], [coordinates[0]+1, coordinates[1]], [coordinates[0], coordinates[1]+1]];\n\n        for (var coordinate of coordinatesToCheck) {\n          recursivelyPaintBucket(coordinate, tolerance, colourToReplace, colourToCompare);\n        }\n      }\n    }\n  }\n  recursivelyPaintBucket([x, y], 0.20, [255, 255, 255, 255], currPixel);\n  return canvas; \n}\n\nfunction imageDataToMatrix(imageData, width) {\n  var to_ret = [];\n  var temp = [];\n  var group = 0; \n  console.log(imageData.data.length);\n  for(var i = 0; i < imageData.data.length; i+=4) {\n    temp.push([imageData.data[i], imageData.data[i+1], imageData.data[i+2], imageData.data[i+3]]);\n    if ((group+1) % width === 0 ) {\n      to_ret.push(temp);\n      temp = [];\n    }\n    group += 1;\n  }\n  return to_ret; \n}\n\n\n// current tool that is in use\nwindow.current =  <Tool url=\"https://image.flaticon.com/icons/png/512/66/66246.png\" text=\"paintbrush\" onCanvasClick={dothing} onCanvasHover={dothing}/>;\n\n\nclass App extends React.Component {\n\n  render() {\n    return (\n      <div className=\"App\">\n        <header className=\"App-header\">\n          \n          <CanvasComponent /> \n          {window.current}\n          <Tool url=\"https://cdn4.iconfinder.com/data/icons/proglyphs-design/512/Paint_Bucket-512.png\" text=\"doggie time\" onCanvasClick={paintBucketClick} onCanvasHover={donothing} />\n        </header>\n      </div>\n    );\n  }\n}\n\n\n\n\n\n\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}